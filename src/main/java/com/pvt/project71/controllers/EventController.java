package com.pvt.project71.controllers;

import com.pvt.project71.domain.dto.EventDto;
import com.pvt.project71.domain.entities.EventEntity;
import com.pvt.project71.domain.entities.UserEntity;
import com.pvt.project71.mappers.Mapper;
import com.pvt.project71.services.EventService;
import com.pvt.project71.services.JwtService;
import com.pvt.project71.services.UserService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Controller
public class EventController {

    private EventService eventService;
    private UserService userService;

    private Mapper<EventEntity, EventDto> eventMapper;
    private JwtService jwtService;

    public EventController(EventService eventService, UserService userService, Mapper<EventEntity, EventDto> eventMapper, JwtService jwtService) {
        this.eventService = eventService;
        this.userService = userService;
        this.eventMapper = eventMapper;
        this.jwtService = jwtService;
    }

    /**
     *Creates a new Event.
     * <p><b>POST</b><code>/events</code></p>
     * @param event Json Body. Expected fields:
     *              <ul>
     *              <li><b>name</b>(String, required)</li>
     *              <li><b>description</b>(String, optional)</li>
     *              <li><b>bannerUrl</b>(String, optional), url to the banner image stored on the server, if the event has one</li>
     *              <li><b>dates</b>(List of dates, required) in format "yyyy-mm-ddThh:mm"<ul>
     *                  <li><b>startsAt</b>(date, optional), if left null it will start at creation</li>
     *                  <li><b>endsAt</b>(date, required)</li>
     *              </ul></li></ul>
     * @param userToken Token to verify user and link as creator.
     * @return ResponseEntity with status 201 and the created event, containing its autogenerated id.
     *
     * <p><b>Possible Errors:</b></p><ul>
     *     <li><b>400 Bad Request</b> - Missing fields or wrongly parsed Json.</li>
     *     <li><b>401 Unauthorized</b> - Missing or invalid token.</li>
     * </ul>
     * <p><b>Example JSON:</b></p>
     * <pre>
     * {"name": "Example Event", "description": "An Example Event", "bannerUrl": "imageLink", "dates": { "startsAt":
     * "2025-09-01T09:00", "endsAt": "2025-09-01T17:00"}}
     * </pre>
     */
    @PostMapping(path = "/events")
    public ResponseEntity<EventDto> createEvent(@RequestBody EventDto event, @AuthenticationPrincipal Jwt userToken) {
        if (event.getDates() == null) {
            return new ResponseEntity<EventDto>(HttpStatus.BAD_REQUEST);
        }if (event.getDates().getEndsAt() == null) {
            return new ResponseEntity<EventDto>(HttpStatus.BAD_REQUEST);
        } if (!jwtService.isTokenValid(userToken)) {
            return new ResponseEntity(HttpStatus.UNAUTHORIZED);
        }
        event.getDates().setCreatedAt(null);
        EventEntity eventEntity = eventMapper.mapFrom(event);

        Optional<UserEntity> creator = userService.findOne(userToken.getSubject());
        if (creator.isEmpty()) {
            return new ResponseEntity<EventDto>(HttpStatus.UNAUTHORIZED);
        }
        userService.makeAdmin(creator.get(), eventEntity);
        eventEntity.setAdminUsers(new ArrayList<>());
        eventEntity.getAdminUsers().add(creator.get());
        eventEntity.setSchool(creator.get().getSchool());
        EventEntity savedEvent = eventService.save(eventEntity, creator.get());
        return new ResponseEntity<>(eventMapper.mapTo(savedEvent), HttpStatus.CREATED);
    }

    /**
     * Get existing Events that are active or upcoming based on users school. This can optionally also send a school as a query param
     * to override the users school.
     * <p><b>GET</b><code>/events</code></p>
     * @return a list of Events with status 200.
     */
    @GetMapping(path = "/events")
    public ResponseEntity<List<EventDto>> listEvents(
            @RequestParam(value = "school", required = false) String school,
            @AuthenticationPrincipal Jwt userToken) {

        if (!jwtService.isTokenValid(userToken)) {
            return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
        }
        Optional<UserEntity> user = userService.findOne(userToken.getSubject());
        if (user.isEmpty()) {
            return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
        }
        List<EventEntity> events = (school == null)
                ? eventService.findAllBySchool(user.get().getSchool())
                : eventService.findAllBySchool(school);

        List<EventDto> dtos = events.stream()
                .map(eventMapper::mapTo)
                .collect(Collectors.toList());

        return ResponseEntity.ok(dtos);
    }

    /**
     * Get a specific Event.
     * <p><b>GET</b><code>/events/{id}</code></p>
     * @param id The Events id.
     * @return The Event with the specific id with status 200.
     * <p><b>Possible Errors:</b></p><ul>
     *     <li><p><b>404 Not Found</b> - If no events exists with the id.</p></li>
     * </ul>
     */
    @GetMapping(path = "/events/{id}")
    public ResponseEntity<EventDto> getEvent(@PathVariable("id") Integer id) {
        Optional<EventEntity> foundEvent = eventService.findOne(id);
        return foundEvent.map(eventEntity -> {
            EventDto eventDto = eventMapper.mapTo(eventEntity);
            return new ResponseEntity<>(eventDto, HttpStatus.OK);
        }).orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND));
    }

    /**
     * Full update of an Event. Anything left blank will be updated to blank.
     * <p><b>PUT</b><code>/events/{id}</code></p>
     * @param id Id of the event that will be updated.
     * @param eventDto Json Body. Expected fields:
     *      <ul>
     *            <li><b>id</b>(Integer, optional), will be overwritten by {id} in the url</li>
     *            <li><b>name</b>(String, required)</li>
     *            <li><b>description</b>(String, optional)</li>
     *            <li><b>bannerUrl</b>(String, optional), url to the banner image stored on the server, if the event has one</li>
     *            <li><b>dates</b>(List of dates, not required), no dates except <code>updatedAt</code> can be changed, but that is done by the server.</li>
     *            </ul>
     *@param userToken Token to verify user and make sure that it is an Admin for the Event.
     *
     *
     * @return A responseEntity with status 200 containing the updated Event.
     * <p><b>Possible Errors:</b></p> <ul>
     *     <li><b>404 Not Found</b> - If Event with id doesn't exist.</li>
     *     <li><b>401 Unauthorized</b> - If Token is invalid or cant be linked to a user.</li>
     *     <li><b>403 Forbidden</b> - If the user from token is not an admin for the Event.</li>
     * </ul>
     *
     * <p><b>Example JSON:</b></p>
     *   <pre>
     *    {"name": "Example Event", "description": "An Example Event that is updated", "bannerUrl": "imageLink"}
     *   </pre>
     */
    @PutMapping(path = "/events/{id}")
    public ResponseEntity<EventDto> fullUpdateEvent(
            @PathVariable("id") Integer id,
            @RequestBody EventDto eventDto,
            @AuthenticationPrincipal Jwt userToken) {

        if (!eventService.isExists(id)) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        } if (eventService.findOne(id).get().isDefault() || userToken == null) {
            return new ResponseEntity<>(HttpStatus.FORBIDDEN); //Ingen får ändra på default event
        }
        Optional<UserEntity> user = userService.findOne(userToken.getSubject());
        if (user.isEmpty()) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
        EventEntity found = eventService.findOne(id).get();
        eventDto.setId(id);
        eventDto.setDates(found.getDates());
        eventDto.getDates().setUpdatedAt(LocalDateTime.now());
        EventEntity eventEntity = eventMapper.mapFrom(eventDto);
        eventEntity.setSchool(user.get().getSchool());
        eventEntity.setAdminUsers(found.getAdminUsers());
        EventEntity savedEventEntity = eventService.save(eventEntity, user.get());
        return new ResponseEntity<>(
                eventMapper.mapTo(savedEventEntity),
                HttpStatus.OK
        );
    }
    /**
     * Partial update of an Event. A Partial update only updates fields that are sent, empty fields are ignored.
     * <p><b>PATCH</b><code>/events/{id}</code></p>
     * @param id Id of the event that will be updated.
     * @param eventDto Json Body. Expected fields:
     *      <ul>
     *            <li><b>id</b>(Integer, optional), will be overwritten by {id} in the url</li>
     *            <li><b>name</b>(String, optional)</li>
     *            <li><b>description</b>(String, optional)</li>
     *            <li><b>bannerUrl</b>(String, optional), url to the banner image stored on the server, if the event has one</li>
     *            <li><b>dates</b>(List of dates, not required), no dates except <code>updatedAt</code> can be changed, but that is done by the server.</li>
     *            </ul>
     *@param userToken Token to verify user and make sure that it is an Admin for the Event.

     * @return A responseEntity with status 200 containing the updated Event.
     * <p><b>Possible Errors:</b></p> <ul>
     *     <li><b>404 Not Found</b> - If Event with id doesn't exist.</li>
     *     <li><b>401 Unauthorized</b> - If Token is invalid or cant be linked to a user.</li>
     *     <li><b>403 Forbidden</b> - If the user from token is not an admin for the Event.</li>
     * </ul>
     *
     * <p><b>Example JSON:</b></p>
     *   <pre>
     *    {"name": "Example Event", "bannerUrl": "newimageLink"}
     *   </pre>
     */
    @PatchMapping(path = "/events/{id}")
    public ResponseEntity<EventDto> partialUpdateEvent(
            @PathVariable("id") Integer id,
            @RequestBody EventDto eventDto,
            @AuthenticationPrincipal Jwt userToken) {

        if (!eventService.isExists(id)) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        } if (eventService.findOne(id).get().isDefault()) {
            return new ResponseEntity<>(HttpStatus.FORBIDDEN);
        }if (userToken == null) {
            return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
        }
        Optional<UserEntity> user = userService.findOne(userToken.getSubject());
        if (user.isEmpty()) {
            return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
        }
        EventEntity eventEntity = eventMapper.mapFrom(eventDto);
        EventEntity updatedEventEntity = eventService.partialUpdate(id, eventEntity, user.get());
        return new ResponseEntity<>(eventMapper.mapTo(updatedEventEntity), HttpStatus.OK);
    }

    /**
     * Deletes an Event.
     * <p><b>DELETE</b><code>/events/{id}</code></p>
     * @param id Id of Event to be deleted
     * @param userToken Token to verify user and make sure that it is an Admin for the Event.
     * @return Status 204
     * <p><b>Possible Errors:</b></p><ul>
     *     <li><b>404 Not Found</b> - If Event doesn't Exist.</li>
     *     <li><b>401 Unauthorized</b> - If token is invalid or cant be linked to a user.</li>
     *     <li><b>403 Forbidden</b> - If the user isn't an Admin for the Event.</li>
     * </ul>
     */
    @DeleteMapping(path = "/events/{id}")
    public ResponseEntity deleteEvent(
            @PathVariable("id") Integer id,
            @AuthenticationPrincipal Jwt userToken) {
        if (!eventService.isExists(id)) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        } if (eventService.findOne(id).get().isDefault()) {
            return new ResponseEntity<>(HttpStatus.FORBIDDEN);
        } if (!jwtService.isTokenValid(userToken)) {
            return new ResponseEntity(HttpStatus.UNAUTHORIZED);
        }
        Optional<UserEntity> user = userService.findOne(userToken.getSubject());
        if (user.isEmpty()) {
            return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
        }
        eventService.delete(id, user.get());
        return new ResponseEntity(HttpStatus.NO_CONTENT);
    }


    /**
     * Add a new Admin to an Event.
     * <p><b>PATCH</b><code>/events/{id}/admins/add{email}</code></p>
     * @param id Id of the Event.
     * @param email Email of the user to be added as admin.
     * @param userToken Token of the user adding the other user as an admin.
     * @return The event and status code 200, the event will not be showing any difference on front end though.
     * <p><b>Possible Errors</b></p> <ul>
     *     <li><b>401 Unauthorized</b> - If the token is invalid.</li>
     *     <li><b>403 Forbidden</b> - If the User trying to add someone isn't an admin themselves</li>
     *     <li><b>404 Not Found</b> - If the user to add doesn't exist, or the event doesn't exist.</li>
     *     <li><b>409 Conflict</b> - If max admins has already been reached, or the new admin is already an admin for the event</li>
     * </ul>
     */
    @PatchMapping(path = "/events/{id}/admins/add/{email}")
    public ResponseEntity<EventDto> addAdminToEvent(@PathVariable("id") Integer id,
                                                    @PathVariable("email") String email,
                                                    @AuthenticationPrincipal Jwt userToken) {
        if (!eventService.isExists(id)) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        } if (eventService.findOne(id).get().isDefault()) {
            return new ResponseEntity<>(HttpStatus.FORBIDDEN); //Ingen får ändra på default event
        }
        Optional<UserEntity> toAdd = userService.findOne(email);
        EventEntity eventEntity = eventService.findOne(id).get();
        if (toAdd.isEmpty()) {
            return new ResponseEntity<EventDto>(HttpStatus.NOT_FOUND);
        } if (eventEntity.getAdminUsers().contains(toAdd)) {
            return new ResponseEntity<EventDto>(HttpStatus.CONFLICT);
        } if (!jwtService.isTokenValid(userToken)) {
            return new ResponseEntity(HttpStatus.UNAUTHORIZED);
        }
        Optional<UserEntity> user = userService.findOne(userToken.getSubject());
        if (user.isEmpty()) {
            return new ResponseEntity<EventDto>(HttpStatus.UNAUTHORIZED);
        }
        eventEntity = eventService.addAdmin(eventEntity, toAdd.get(), user.get());
        return new ResponseEntity<>(eventMapper.mapTo(eventEntity), HttpStatus.OK);
    }

    /**
     * Leave as an admin. You can't kick out anyone but yourself from the admins.
     * @param id Id for the event to leave as admin.
     * @param userToken Token of the user leaving.
     * @return The Event with status 200.
     * <p><b>Possible Errors:</b></p> <ul>
     *     <li><b>401 Unauthorized</b> - If the token is invalid or can't be linked to a user.</li>
     *     <li><b>404 Not Found</b> - If the user is not an Admin, or the Event doesn't exist</li>
     * </ul>
     */
    @PatchMapping(path = "/events/{id}/admins/leave")
    public ResponseEntity<EventDto> leaveEventAsAdmin(@PathVariable("id") Integer id,
                                                      @AuthenticationPrincipal Jwt userToken) {
        if (!eventService.isExists(id)) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        } if (eventService.findOne(id).get().isDefault()) {
            return new ResponseEntity<>(HttpStatus.FORBIDDEN); //Ingen får ändra på default event
        } if (!jwtService.isTokenValid(userToken)) {
            return new ResponseEntity(HttpStatus.UNAUTHORIZED);
        }
        EventEntity eventEntity = eventService.findOne(id).get();

        Optional<UserEntity> user = userService.findOne(userToken.getSubject());
        if (user.isEmpty()) {
            return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
        }
        eventEntity = eventService.removeAdmin(eventEntity, user.get());
        return new ResponseEntity<>(eventMapper.mapTo(eventEntity), HttpStatus.OK);
    }

}
